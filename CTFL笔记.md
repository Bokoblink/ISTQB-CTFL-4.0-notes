# CTFL

## 1.基础

### 1.1什么是测试

- 一系列发现缺陷和评估软件产品质量的活动
- 不完全专注于验证测试对象，还涉及确认

#### 1.1.1 测试目的

- 评估工作产品，例如需求、用户故事、设计和代码
- 触发失效并发现缺陷
- 确保所需的被测对象的覆盖率
- 降低软件质量不足的风险级别
- 验证是否已满足指定需求
- 验证测试对象是否符合合同、法律和监管要求
- 向利益相关方提供信息，使他们能够做出明智的决策
- 建立对被测对象质量的信心
- 确认被测对象是否完整并按利益相关方的预期工作

#### 1.1.2 测试与调试

- 当动态测试触发失效时，调试涉及查找失效原因
  - 重现失效
  - 诊断（找到根本原因）
  - 修复失效的原因
- 确认测试

### 1.2 为什么需要测试？

有助于在设定的范围、时间、质量和预算限制内实现商定的目标

#### 1.2.1 测试对成功的贡献

- 提供了经济高效的发现缺陷的方法
  - 试间接地提高测试对象的质量
- 提供了在软件开发生存周期（SDLC）的各个阶段直接评估测试对象质量的方法
  - 有助于做出进入软件开发生存周期（SDLC）下一阶段的决策
- 为用户提供了开发项目的间接代表
  - 测试人员确保他们对用户需求的理解贯穿于整个开发生存周期
- 为了满足合同或法律要求，或遵守监管标准

#### 1.2.2 测试和质量保证（QA）

- 质量控制（QC）
  - 以产品为导向的纠正方法
  - 侧重于支持实现适当质量级别
  - 测试是质量控制的主要形式
  - 测试结果用于修复缺陷
- 质量保证（QA）
  - 是以过程为导向的预防性方法
  - 侧重于过程的实施和改进
  - 适用于开发和测试过程，是项目中每个人的责任
  - 测试结果提供关于开发和测试过程执行情况的反馈

#### 1.2.3 错误、缺陷、失效和根本原因

- 人会犯错误（error、mistake），从而产生缺陷（defect、fault，bug），进而导致失效（failure）
- 错误和缺陷并不是导致失效的唯一原因
- 根本原因是问题发生的根本原因

### 1.3 测试原则

- 测试说明缺陷存在，不能证明缺陷不存在
- 穷尽测试是不可能的
- 早期测试可以节省时间和费用
- 缺陷的集群效应
  - 通常大多数已发现的缺陷出现在少数系统组件中
  - 或少数系统组件是引起大多数操作失效的原因
- 测试会无效
  - 如果重复多次相同的测试，在检测新缺陷方面会变得越来越无效
- 测试活动依赖于测试环境
- 不存在缺陷的谬论
  - 期望软件验证会确保系统的成功是一种谬论

### 1.4 测试活动、测试件和测试角色

#### 1.4.1 测试活动和任务

- 测试规划
  - 定义测试目的
  - 在整体环境的约束下选择可达到目的的最佳方法
  - 输出工作产品：
    - 包括：测试计划、测试进度表、风险记录表以及入口和出口准则
    - 风险记录表：
      - 包含风险、风险可能性、风险影响以及风险缓解信息的列表
    - 测试进度表、风险记录表、入口和出口准则：
      - 通常是测试计划的一部分

- 测试监测和控制
  - 持续检查所有测试活动，将实际进度与计划进行比较
  - 采取必要的行动来实现测试目的
  - 输出工作产品：
    - 包括：测试过程报告、文档化的控制指令和风险信息
- 测试分析
  - 分析测试依据以识别可测试的特征，定义相关测试条件的优先级，以及有关的风险和风险级别
  - 对测试依据和测试对象进行评估，以识别它们可能包含的缺陷并评估其可测试性
  - 通常由掌握测试技术的人员提供支持
  - 根据可度量的覆盖准则回答“测试什么？”的问题
  - 输出工作产品：
    - 包括：（按优先级排序）测试条件（例如，验收准则），在测试依据中发现的有关缺陷的缺陷报告（如果该缺陷还没有被直接修复）。
- 测试设计
  - 如何将测试条件转化成测试用例和其他测试件
  - 通常与识别覆盖项有关，可以作为具体选择哪些测试用例输入的指南
  - 定义测试数据需求、设计测试环境以及确认所需的基础设施和工具
  - 测试设计回答“如何测试？”的问题
  - 输出工作产品：
    - 包括：（按优先级排序）测试用例、测试章程、覆盖项、测试数据需求和测试环境需求
- 测试实施
  - 创建或获取测试执行所需的测试件（例如，测试数据）
  - 测试用例可以被组织到测试规程中，并且经常被组装成测试套件使用
  - 创建人工和自动化的测试脚本
  - 为实现高效的测试执行，测试规程要按照优先级在测试执行进度表中排序
  - 构建测试环境，并验证其设置的正确性
  - 输出工作产品：
    - 包括：测试规程、自动化测试脚本、测试套件、测试数据、测试执行计划和测试环境要素。
    - 测试环境要素的实例包括：
      - 桩、驱动器、模拟器和服务虚拟化。
- 测试执行
  - 根据测试执行进度表执行测试（测试运行）
  - 既可以人工进行也可以自动进行
  - 测试执行可以采取多种形式，包括持续测试或结对测试会话
  - 将测试的实际结果与预期结果进行比较
  - 记录测试结果
  - 分析导致异常发生的可能原因。该分析以观察到的失效为依据报告异常
  - 输出工作产品：
    - 包括：测试执行工作产品包括：测试日志和缺陷报告
- 测试完成
  - 通常发生在项目里程碑处（例如，发布、迭代结束、测试级别完成）
  - 针对任何未解决的缺陷、变更请求或产品待办事项列表
  - 未来可能有用的测试件都会被识别并归档，或移交给适当的团队
  - 测试环境被恢复到约定状态
  - 对测试活动进行分析，以确定未来迭代、发布或项目的经验教训和改进
  - 创建测试完成报告并与利益相关方沟通
  - 输出工作产品：
    - 测试完成工作产品包括：测试完成报告、后续项目或迭代的改进行动项、文档化的经验教训和变更请求（例如，产品待办事项）

#### 1.4.2 周境中的测试过程

- 测试的执行方式将取决于多种环境因素
  - 利益相关方（需要、期望、需求、合作意愿等）。
  - 团队成员（技能、知识、经验水平、工作效率、培训要求等）。
  - 业务领域（测试对象的重要性、已识别的风险、市场要求、特定的法律法规等）。
  - 技术因素（软件类型、产品架构、使用的技术等）。
  - 项目约束（范围、时间、预算、资源等）。
  - 组织因素（组织架构、现有政策、已在应用的实践等）。
  - 软件开发生存周期（工程实践、开发方法等）。
  - 工具（可用性、易用性、依从性等）。

#### 1.4.4 测试依据和测试件之间的可追溯性

- 为了实施有效的测试监测和控制，测试过程中建立和维护测试依据元素、与元素相关的测试件（例如测试条件、风险、测试用例）、测试结果和发现的缺陷之间的可追溯性非常重要
- 准确的可追溯性可支持覆盖评估，测试依据中定义可衡量的覆盖准则非常有用。覆盖准则可以作为关键绩效指标，推动活动的进行，以展示测试目的达成的程度
- 良好的可追溯性还可以确定变更的影响、促进测试审计，并有助于满足 IT治理准则
- 可追溯性提供了针对业务目标评估产品质量、过程能力和项目进展的信息

#### 1.4.5 测试活动中的角色

- 测试管理角色
  - 全面负责测试过程、测试团队以及测试活动的领导工作
  - 主要关注测试规划、测试监测和控制以及测试完成活动
  - 测试管理角色开展工作的方式因周境而异
- 测试角色
  - 色对测试的工程（技术）方面负有整体责任
  - 主要关注测试分析、测试设计、测试实施和测试执行等活动

- 不同的人员可能在不同的时间点扮演这些角色。也可以一个人同时承担测试和测试管理的角色

### 1.5 测试中的基本技能和良好实践

#### 1.5.1 测试所需的通用技能

- 测试知识（例如，通过使用测试技术提高测试的有效性）。
- 全面、细致、好奇心、注重细节、有条不紊（对识别缺陷，尤其对于发现难以发现的缺陷）。
- 良好的沟通技巧、积极的倾听、具有团队合作精神（与所有利益相关方有效互动，以可理解的方式向他人传递信息，并报告和讨论缺陷）。
- 分析性思维、批判性思维、创造力（用以提高测试的有效性）。
- 技术知识（提高测试效率，例如使用适当的测试工具）。
- 领域知识（能够理解并与最终用户/业务代表沟通）。

#### 1.5.2 完整团队方法

- 在团队环境中有效地工作并积极为团队目标做出贡献
- 在完整团队方法中，所有团队成员都具有进行各种类型任务的知识和能力，并且每个人都要对质量负责
- 团队成员共享相同的工作空间（物理或虚拟），共址工作有助于沟通和互动
- 优势：
  - 可提升团队活力
  - 增强团队内部的沟通和协作
  - 通过充分利用团队内不同的技能，产生协同效应，从而使项目获益
- 由于对周境的依赖，完整团队方法可能并不总是适用

#### 1.5.3 测试独立性

- 因为作者和测试人员之间存在认知偏差，因此一定程度的独立性可以使测试人员更有效地发现缺陷。
- 工作产品可以交由：
  - 作者进行测试（无独立性）
  - 来自作者同一团队的同行进行测试（一定的独立性）
  - 组织内非作者团队的测试人员进行测试（高独立性）
  - 组织外部的测试人员进行测试（非常高的独立性）
- 对于大多数项目而言，通常最好使用多个独立性级别的测试。

- 独立的测试人员主要优势在于
  - 与开发人员相比，由于背景、技术视角、以及认知偏向的差异，更可能识别出不同类型的失效和缺陷
  - 可以验证、质疑或推翻利益相关方在系统规格说明和系统实施期间所做的假设
- 缺点
  - 独立的测试人员可能与开发团队脱离
  - 可能导致缺乏协作、沟通出现问题或与开发团队形成对立关系
  - 开发人员可能会丧失对质量的责任感
  - 独立测试人员可能被视为瓶颈，或被指责为发布延迟负有责任

## **2. 软件开发生存周期中的测试**

### 2.1 软件开发生存周期中的测试

- 软件开发生存周期（SDLC）模型是对软件开发过程的抽象、概要表述
- SDLC 模型定义了软件开发过程中不同开发阶段和活动类型之间的逻辑和时间关系
- SDLC 模型的示例：
  - 顺序开发模型（例如瀑布模型、V 模型）
  - 迭代开发模型（例如螺旋模型、原型模型）
  - 增量开发模型（例如统一软件开发过程）

#### 2.1.1 软件开发生存周期对测试的影响

- 测试活动的范围和时间安排（例如测试级别和测试类型）
- 测试文档的详细程度
- 测试技术和测试方法的选择
- 测试自动化程度
- 测试人员的角色和职责

#### 2.1.2 软件开发生存周期与良好的测试实践

- 每个软件开发活动，都有相应的测试活动，以便对所有开发活动进行质量控制
- 不同测试级别具有特定且不同的测试目标，可以确保测试既全面又避免冗余
- 给定测试级别的测试分析和设计始于相应的软件开发生存周期开发阶段，以便测试能够遵循早期测试的原则
- 相关文档的初稿完成时，测试人员立即参与评审工作产品，以便早期测试和缺陷检测，从而支持测试左移方法

#### 2.1.3 测试是软件开发的驱动力

- 测试驱动开发（TDD）、验收测试驱动开发（ATDD）和行为驱动开发（BDD）是类似的开发方法，将测试定义为指导开发的手段
- 这些方法都实现了早期测试的原则并遵循左移方法
- 为测试在编写代码之前定义
- 它们支持迭代开发模型
- 测试驱动开发（TDD）
  - 通过测试用例来指导编码（而不是详尽的软件设计）
  - 先编写测试，后编写代码以满足测试，最后对测试和代码进行重构。
- 验收测试驱动开发（ATDD）
  - 作为系统设计过程的一部分，从验收准则中导出测试
  - 在部分应用程序开发前，编写测试，以满足测试的要求。
- 行为驱动开发（BDD）：
  - 用简化的自然语言编写测试用例来表达应用程序的期望行为，利益相关方容易理解，通常使用Given/When/Then 格式。
  - 自动将测试用例转化为可执行的测试

#### 2.1.4 DevOps 与测试

- DevOps 是一种组织方法
- 旨在通过使开发（包括测试）和运维部门共同努力，实现一系列通用目标，从而实现协同效应
- 要求组织内部进行文化转变，将开发和运维的职能同等看待，以弥合开发（包括测试）和运维之间的差距
- 提倡团队的自主权、快速反馈、集成工具链以及持续集成（CI）和持续交付（CD）等技术实践
- 通过 DevOps 交付流水线，软件团队可以更快地构建、测试和发布高质量的代码
- 优势：
  - 代码质量的快速反馈，并判断变更是否对现有代码产生不利影响
  - 持续集成（CI）通过鼓励开发人员提交高质量的代码，并辅以组件测试和静态分析，在测试中实现左移方法
  - 促进 CI/CD 自动化过程，有助于建立稳定的测试环境
  - 更加关注非功能性质量特性（例如性能、可靠性）
  - 交付流水线的自动化，减少人工重复测试的需求
  - 由于自动化回归测试的规模和范围，降低了回归风险

- 风险和挑战：
  - 必须定义和建立 DevOps 交付流水线
  - 必须引入和维护 CI/CD 工具
  - 测试自动化需要额外资源，这些资源可能难以建立和维护

#### 2.1.5 左移的方法

- 测试早期介入的原则有时被称为“左移”
- 是软件开发生存周期中较早进行测试的方法
- 左移建议测试应该早期进行，但不能因此忽视软件开发生存周期的后期测试
- 明如何实现测试 “左移”：
  - 从测试的角度评审规格说明。对规格说明进行评审通常可以发现潜在的缺陷，例如规格说明表述模糊、不完整和不一致。
  - 编码之前编写测试用例，在代码实现过程中通过测试用具（test harness）运行代码。
  - 使用持续集成（CI）和持续交付（CD），提供快速反馈和自动化组件测试，可以在代码提交到代码库时运行源代码测试。
  - 在动态测试之前或作为自动化过程的一部分对源代码进行静态分析。
  - 在可能的情况下，从组件测试级别开始进行非功能性测试。这是左移形式之一，因为非功能性测试类型通常在系统完整且代表性的测试环境就绪后，在软件开发生存周期的后期执行。
- 法可能会在过程早期增加培训、工作量和成本，但可以节省过程后期的工作量和成本

#### 2.1.6 回顾与过程改进

- 回顾会议作为发布的里程碑，通常在项目或迭代结束后，按需召开
- 讨论以下内容：
  - 哪些工作是成功的，应予以保留？
  - 哪些工作没成功，可以改进？
  - 如何整合改进并保持未来成功？
- 测试的典型收益包括：
  - 增加测试的有效性/效率（例如，实施过程改进的建议）
  - 提高测试件的质量（例如，联合评审测试过程）
  - 团队凝聚力和学习能力（例如，提出问题，列出改进点）
  - 提高测试依据的质量（例如，处理和解决需求范围和质量方面的缺陷）
  - 改善开发和测试之间的合作（例如，定期评审和优化协作）

### 2.2 测试级别和测试类型

- 测试级别是共同组织和管理的测试活动组
- 每个测试级别都是测试过程的一个实例，在给定的开发阶段，从单个组件到完整系统，或在适用情况下，乃至到系统的系统，执行软件相关的测试过程。
- 测试级别与软件开发生存周期内的其他活动相关
- 测试类型，是与某种质量特性相关的测试活动的集合，这些测试活动中的大部分可以在每个测试级别进行

#### 2.2.1 测试级别



## 4. 测试分析和设计

### 4.1 测试技术概述

- 支持测试人员开展测试分析（测试什么）和测试设计（如何测试）
- 术有助于以系统的方式开发相对较小但充分的测试用例集
- 在测试分析和设计期间帮助测试人员定义测试条件、识别覆盖项，并识别测试数据
- 黑盒测试技术
  - 也称为基于规格说明的技术
  - 基于对测试对象的特定行为进行分析，而不考虑其内部结构
  - 测试用例不依赖于软件的实现方式
- 白盒测试技术
  - 也称为基于结构的技术
  - 基于对测试对象的内部结构和处理进行分析
  - 由于测试用例依赖于软件的设计方式，因此白盒测试只能在测试对象的设计或实现之后创建
- 基于经验的测试技术
  - 有效地利用测试人员的知识和经验进行测试用例的设计和实施
  - 有效性在很大程度上取决于测试人员的技能
  - 能检测出使用黑盒和白盒测试技术可能会遗漏的缺陷
  - 是对黑盒和白盒测试技术的补充

### 4.2 黑盒测试技术

#### 4.2.1 等价类划分

- 基于给定分区中的所有元素都会被测试对象以相同方式处理的预期将数据划分为多个分区（称为等价类）
- 原理：如果测试用例测试了等价类中的一个值，并检测到缺陷，那么任何来自同一等价类的其他值的测试用例也应该能够检测到这个缺陷。因此，每个分区执行一个测试就足够了
- 分可应用于与测试对象相关的任何数据元素，包括输入、输出、配置项、内部值、与时间相关的值和接口参数
- 可以是连续的或离散的、有序的或无序的、有限的或无限的
- 不能重叠，并且必须是非空集合
- 有效等价类、无效等价类
  - 包含有效值的分区称为有效等价类
  - 包含无效值的分区称为无效等价类
- 在等价类划分中，覆盖项是等价类划分
  - 覆盖率是由被测试用例执行的等价类数量，除以已确定的等价类总数来度量的，并以百分比表示
- 单选项覆盖、多组等价类
  - 许多测试对象包括多组等价类分区，这意味着一个测试用例将覆盖来自不同等价类组的等价类
  - 在多组等价类情况下，最简单的覆盖准则被称为单选项覆盖
  - 单选项覆盖要求测试用例执行来自每个等价类组的每个等价类至少一次

#### 4.2.2 边界值分析

- 边界值分析（BVA）是基于执行等价类边界的技术
- 边界值分析只能用于有序分区
- 分区的最小值和最大值是它的边界值
- 如果两个元素属于同一个分区，那么它们之间的所有元素也必须属于该分区。
- 侧重于分区的边界值，因为开发人员更容易在这些边界值上出错
- 二值边界值和三值边界值分析
  - 二值边界值分析
    - 每个边界值都有两个覆盖项：该边界值以及属于相邻分区的最近邻值
    - 测试用例必须执行所有的覆盖项，即所有已识别的边界值
    - 覆盖率是由已被执行的边界值的数量，除以已识别的边界值总数度量，并以百分比表示
  - 三值边界值分析
    - 每个边界值都有三个覆盖项
    - 该边界值以及两侧的相邻值
    - 某些覆盖项可能不是边界值
    - 测试用例必须执行所有的覆盖项，即已识别的边界值及其相邻值
    - 覆盖率是由已被执行的边界值及其相邻值的数量，除以已识别的边界值及其相邻值的总数度量，并以百分比表示

#### 4.2.3 判定表测试

- 是什么
  - 判定表用于测试系统需求的实现，这些需求指定了不同的条件组合产生不同的结果
  - 是记录复杂逻辑（如业务规则）的有效方法
- 创建判定表
  - 定义了系统的条件和导致的动作，这些组成了判定表的行
  - 判定表的每一列对应了一个判定规则，该规则定义了各种条件的唯一组合以及相关的动作
  - 在有限判定表中，所有条件和动作的值表示为布尔值（“真”或“假”）
  - 在扩展判定表中，某些或者所有条件和动作也可以采用多个值
- 条件的符号
  - “T”（true）表示满足条件
  - “F”（false）表示不满足条件
  - “-”表示条件的取值与动作结果不相关
  - “N/A”表示该条件对于给定的规则是不可行的
  - 动作中
    - “X”表示动作应该发生
    - 空白表示动作不应该发生
  - 也可以使用其他符号
- 完全的判定表有足够多的列来覆盖条件的每种组合
- 判定表测试
  - 覆盖项是包含可行条件组合的列
  - 为了让这种技术达到 100%的覆盖率，测试用例必须执行所有这些列
  - 覆盖率是由已被执行的列数量，除以可执行列的总数度量，并以百分比表示
- 优点
  - 提供了系统化的方法来识别所有的条件组合，否则其中的某些组合可能会被忽视
  - 有助于发现需求中的任何漏洞或不一致
- 如果有很多条件，那么执行所有判定规则可能比较耗时，因为规则的数量会随着条件的数量呈指数增长
  - 为了减少需要执行的规则的数量，可以使用最小化判定表或基于风险的方法

#### 4.2.4 状态转移测试

- 是什么
  - 状态转移图通过显示系统可能的状态和有效的状态转移来模拟系统的行为
  - 转移由事件触发，该事件可能由守护条件进一步限定
  - 假设转移是瞬时的，有时可能导致软件采取动作
  - 常见的转移标签语法：“事件 [守护条件] / 动作”
- 状态表
  - 是等价于状态转移图的一种模型
  - 行表示状态，列表示事件（可能还包括守护条件）
  - 状态表条目（单元格）表示转移，并包含目标状态以及结果动作（如果已定义）
  - 与状态转移图相反，状态表通过空白单元格明确显示无效的转移
- 测试用例
  - 基于状态转移图或状态表的测试用例通常表示为事件序列，这些事件会导致一系列的状态变化（和动作，如果需要）
  - 一个测试用例可以并且通常会覆盖状态之间的若干次转移
- 覆盖准则
  - 全状态覆盖
    - 覆盖项是状态
    - 为了达到 100%的全状态覆盖率，测试用例必须确保所有状态都被访问到
    - 覆盖率是由已被访问的状态数量，除以状态总数度量，并以百分比表示
  - 有效转移覆盖
    - 覆盖项是单个有效转移
    - 为了达到 100%的覆盖率，测试用例必须执行所有的有效转移
    - 覆盖率是由已被执行的有效转移的数量，除以有效转移的总数度量，并以百分比表示
  - 全转移覆盖中
    - 覆盖项是状态表中显示的所有转移
    - 为了达到 100%的全转移覆盖率，测试用例必须执行所有的有效转移，并尝试执行无效转移
    - 在单个测试用例中仅测试一个无效转移有助于避免错误屏蔽，即一个缺陷阻止另一个缺陷被发现的情况。
    - 覆盖率是由已执行的测试用例所覆盖的执行有效转移和尝试无效转移的数量，除以有效和无效转移的总数度量，并以百分比表示
  - 全状态覆盖弱于有效转移覆盖，因为它通常可以在不执行所有转移的情况下达到
  - 有效转移覆盖是最广泛使用的覆盖准则
  - 达到完整的有效转移覆盖可保证完整的全状态覆盖
  - 达到完整的全转移覆盖可同时保证完整的全状态覆盖和完整的有效转移覆盖，并且应该是关键任务和安全关键软件的最低要求

### 4.3 白盒测试技术

#### 4.3.1 语句测试和语句覆盖

- 覆盖项是可执行语句
- 目的是设计测试用例，通过执行代码中的语句，直到达到可接受的覆盖率级别
- 覆盖率是用测试用例执行的语句数除以代码中可执行语句的总数度量，并以百分比表示
  - 达到 100%语句覆盖率时，能确保代码中的所有可执行语句至少已被执行过一次
  - 带有缺陷的每条语句将被执行到，这可能导致失效，从而证明缺陷的存在
  - 使用测试用例执行语句不能在所有的情况下都检测到缺陷
  - 100%的语句覆盖率不能确保所有的判定逻辑都被测试过

#### 4.3.2 分支测试和分支覆盖

- 覆盖项是分支
- 目的是设计测试用例，以执行代码中的分支，直到达成可接受的覆盖率级别为止
- 覆盖率是用测试用例执行的分支数除以分支总数度量，并以百分比表示
- 当达到 100%的分支覆盖时，代码中的所有分支，都被测试用例执行
  - 使用测试用例来执行分支并不能在所有情况下都检测到缺陷
- 分支覆盖包含语句覆盖
- 如果实现了 100%的分支覆盖率，也就实现了 100%的语句覆盖率（但反之不成立）

#### 4.3.3 白盒测试的价值

- 优点：在测试期间考虑到整个软件实现，有助于在软件规格说明模糊、过时或不完整时检测缺陷
- 弱点：如果软件没有实现一个或多个需求，白盒测试可能无法检测到由此产生的遗漏缺陷
- 用于
  - 白盒技术可用于静态测试
  - 适合于对尚未准备好执行的代码进行评审，以及伪代码和其他可以用控制流图建模的高层逻辑或自顶向下的逻辑
- 作用
  - 仅执行黑盒测试不能提供实际代码覆盖率的度量
  - 白盒覆盖率的度量数据提供了客观的覆盖率度量，并提供了必要的信息，以允许生成额外的测试来提高覆盖率，从而增加对代码的信心

### 4.4 基于经验的测试技术

#### 4.4.1 错误猜测

- 基于测试人员的知识来预测错误、缺陷和失效发生的技术
  - 以前软件的运行方式
  - 开发人员常犯的错误类型以及由这些错误导致的缺陷类型
  - 其他类似应用软件产生的失效类型
- 故障攻击
  - 实现错误猜测的一种系统方法
  - 要求测试人员创建或获取一份可能的错误、缺陷和失效列表，并设计测试来识别与缺陷相关的错误、暴露缺陷、或导致失效
  - 这些列表可以基于经验、缺陷和失效数据，或者基于软件失败原因的常识来构建

#### 4.4.2 探索性测试

- 在了解有关测试对象的同时，设计、执行和评估测试
- 用于更深入地了解测试对象，使用重点测试进行深入探索，并为未测试的区域创建测试
- 